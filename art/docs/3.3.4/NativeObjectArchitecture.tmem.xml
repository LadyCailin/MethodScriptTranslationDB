<translations>
<comment></comment>
<translationBlock>
	<id>art-1715</id>
	<key><![CDATA[Find a bug in this page? %sEdit this page yourself, then submit a pull request.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3040</id>
	<key><![CDATA[Fields may be native as well. In these cases, it is as if they are defined with auto getters and setters that simply set and return the value.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3041</id>
	<key><![CDATA[It is not strictly required that the java class implement mixed, but then the class would be unusable by most native code, so it generally should.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3042</id>
	<key><![CDATA[Then within the java, you must use the @NativeElement annotation on the method with the same name and signature.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3043</id>
	<key><![CDATA[To facilitate this, there are a few architectural features, and a few language features.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3044</id>
	<key><![CDATA[In addition, non-native methods may be defined within the MethodScript, along side native methods.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3045</id>
	<key><![CDATA[All classes in the java marked with the @typeof annotation will be available in the code, regardless of whether or not there is a corresponding ''native class'', and can be used as normal in the java functions, but there will be no fields or methods available in user code. A java class with the typeof annotation and no corresponding MethodScript class will thus be synthesized as such:]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3046</id>
	<key><![CDATA[The native keyword can also be applied to methods within a native class. Native methods outside of a native class are not valid. These methods are defined in MethodScript per normal, but with no method body. The documentation and other method information comes from the MethodScript, but the code itself is defined in the java.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3047</id>
	<key><![CDATA[Precompilation]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3048</id>
	<key><![CDATA[This step is important to reduce startup time, and extensions should follow the same logic when adding native classes.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3049</id>
	<key><![CDATA[It is worth noting that native methods can only work with other native classes, due to the tight coupling between the need for the return value and parameter types to be addressable in the java. No such requirement is placed on non-native methods however, and they may address objects fully defined elsewhere in MethodScript.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3050</id>
	<key><![CDATA[The ParentClasses and ParentInterfaces are calculated based on the return value of the corresponding methods in the java. Any documentation for the class itself will come from the MethodScript definition, if present, and the java class otherwise.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3051</id>
	<key><![CDATA[native class]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3052</id>
	<key><![CDATA[A native class, defined with the ''native class'' keyword, implies that this class is mirroring a class defined in the java, with a @typeof annotation of the same name. This causes the system to merge the two classes' functionality.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3053</id>
	<key><![CDATA[native methods]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3054</id>
	<key><![CDATA[Such methods are not callable by java code, so if this is something that native code requires access to, it should be defined as a native method instead.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3055</id>
	<key><![CDATA[Classes defined directly in MethodScript are pre-compiled at build time. The classes are defined in a certain folder, with files ending in .msc and at build time, these are scanned, compiled into ClassInfo objects, serialized, and stored in the resulting jar. At startup, these files are quickly loaded, pre-compiled, and added to the native class list.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3056</id>
	<key><![CDATA[To increase portability and flexibility, much of the functionality of native objects are defined directly in MethodScript, using most of the same compiler features available to user defined classes. Of course, some of the functionality is required to be different, as native code must be run in some cases, but the goal is to reduce this as much as possible. Doing so allows the compiler to be re-implemented in other languages more easily, and causes the code itself to "eat its own dogfood".]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
</translations>
