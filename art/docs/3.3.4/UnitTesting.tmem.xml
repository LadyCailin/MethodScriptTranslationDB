<translations>
<comment></comment>
<translationBlock>
	<id>art-1715</id>
	<key><![CDATA[Find a bug in this page? %sEdit this page yourself, then submit a pull request.]]></key>
	<comment></comment>
	<translation></translation>
	<auto><![CDATA[Fînd å büg în thîs pågə? %sEdît thîs pågə ʎøürsəlf, thən sübmît å püll rəqüəst.]]></auto>
</translationBlock>
<translationBlock>
	<id>art-2698</id>
	<key><![CDATA[Example]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3669</id>
	<key><![CDATA[For existing mock frameworks in other languages, they are usually quite good, but due to various limitations in the language, there are some key drawbacks. For instance, final classes cannot be mocked, because mocks in these languages are just classes that are created on the fly, and extend a given class, so if the class cannot be extended, it requires even more cumbersome and more complex frameworks to do the mocking. Private methods and fields cannot be accessed by the mocks, and static methods cannot be mocked. These limitations make mocks useless in some cases, and makes it impossible to do a proper unit test. Often, this code is tested in integration or functional tests, but it can be quite a large process to do so, and in theory, if a mock would work, it would be ideal. Given that, MethodScript provides built in support for mocks, including support for mocking final classes, private methods, and static methods.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3670</id>
	<key><![CDATA[In general, unit testing is a mechanism to test individual units of code (hence the name). This is opposed to integration testing or functional testing, though the unit testing framework can be used to do integration testing as well.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3671</id>
	<key><![CDATA[In general, a mock framework is a framework that allows easy yet powerful stubbing/faking, but instead of using real objects such as MyStub or MyFake in the above example, the framework generates what can be thought of as a stub or a fake on the fly. In addition, a mock framework usually contains mechanisms for verifying that the mocked object was called in a certain way, with certain parameters. Additionally, the "code" in the mock can easily be modified at runtime by the test code, so that the behavior can mimic realistic scenarios, with relatively little effort.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3672</id>
	<key><![CDATA[Functional testing, on the other hand, works more like a black box test. The program as a whole is run, as if run by a user. In some cases, this is the most desirable test type, but the unit testing framework does not provide support for this.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3673</id>
	<key><![CDATA[You may name the test method whatever you like, but the return value should be %s, and the method should not take any parameters.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3674</id>
	<key><![CDATA[In general, the unit test framework can be used without mocking, and across larger sets of objects to accomplish what is known as integration testing. The line between this and unit tests can be blurry anyways, but strictly speaking, unit tests should not interact with external objects (other than through mocks). But often times, there is little value in doing such a limited test, as the real test lies in the interaction between various objects. In this case, you can use the unit test framework, minus perhaps the mocks, and this is a perfectly acceptable use of the framework.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3675</id>
	<key><![CDATA[In a unit test, the block of code that is under test is the only thing that should actually be run. Functions often have external side effects though, (such as when calling a method that makes an http call, the server would actually be hit with an http call) which is usually undesirable. There are a number of solutions to this, and the correct one depends heavily on what type of test you're writing, and what your desired outcome is. In general, there are three main types of ''test doubles'':]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3676</id>
	<key><![CDATA[In addition to support for mocks, MethodScript provides a mechanism for running unit tests ''MSUnit''. Most importantly, MethodScript defines some generic annotations, which can be used by all test code, but it also provides a basic runner for the tests. Third party libraries could provide alternative runners, and in fact, when integrating with an IDE, the default runner is not used. Much of the unit test framework is inspired by xUnit, so if you are familiar with unit testing in general, these concepts should not be much of a leap, though there are some extremely notable improvements.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3677</id>
	<key><![CDATA['''Mocks''' are objects pre-programmed with expectations which form a specification of the calls they are expected to receive.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3678</id>
	<key><![CDATA[Scoping]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3679</id>
	<key><![CDATA[Our unit test code that tests the add method might look like this:]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3680</id>
	<key><![CDATA[Global functions can also easily be mocked, using the same general syntax, with the exception that all arguments must be mocked, there is no shortcut for leaving off the arguments.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3681</id>
	<key><![CDATA[In come mocks]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3682</id>
	<key><![CDATA[Integration Testing]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3683</id>
	<key><![CDATA[Assuming that during unit testing, you provide a new instance of MyStub or MyFake, then the rest of the code in the real methods will work as intended. This pattern is often times useful when you have more complex objects, or for integration tests, where creating mocks over and over is tiresome. However, the downside of this approach is that you have to write your code in such a way as to support this, and anyways, if you are writing integrations with third party code which you cannot change, this might be impossible anyways.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3684</id>
	<key><![CDATA[The testAdd method shows that we expect a return value of 4.0 when we add 2 and 2. If these values are not equal, then the test method will throw an AssertException, which will signal to the unit test framework that this test has failed, and the test will end. The other tests in the suite will continue to run, however. We can also mock methods, using the mock framework, which may be useful to bypass some methods that are not under test. The when() function is used to assign mock functionality for a particular method, and is a method with special runtime support, which does not actually execute the parameter passed to it. verify() is special in the same way.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3685</id>
	<key><![CDATA[In addition, global functions can be easily mocked as well.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3686</id>
	<key><![CDATA[This example is not useful, because we are not passing the Calculator object to another object, but merely demonstrates how mocks work. In this case, it's more useful to use a ''spy'' instead. A ''spy'' works more or less like a mock, but unless otherwise instructed, will execute the real method in the underlying object. Unlike a mock, however, creating a spy does need a real instance of the class. If the class has a no arg constructor (even a private one), and this is the appropriate constructor to call for the test, then nothing additional needs doing. However, if you wish the object to be constructed with another constructor, you can provide the instance to the spy function.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3687</id>
	<key><![CDATA['''Stubs''' provide canned answers to calls made during the test, usually not responding at all to anything outside what's programmed in for the test. Stubs may also record information about calls, such as an email gateway stub that remembers the messages it 'sent', or maybe only how many messages it 'sent'.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3688</id>
	<key><![CDATA[At the lowest level, MethodScript provides the core resources needed to properly do unit testing, using special language support for things like mocks, private member access, and other common unit test paradigms, that require unwieldy and cumbersome third party libraries to support.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3689</id>
	<key><![CDATA[Unit Test Framework (MSUnit)]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3690</id>
	<key><![CDATA[In general, tests should be isolated activities. This allows for tests to be run in parallel, prevents dependencies on test run order, and makes writing tests easier to visualize. To support this notion, MethodScript enforces test isolation at a low level. TestSuites are mostly just a logical grouping of tests, but if a method in the test suite is marked as @{BeforeTest} or @{AfterTest}, then these methods will be called before and after each @{Test} method. However, each test is run within its own environment, which is not shared with other test runs. Any changes made to static values (including mocking the behavior of static methods) or other memory based structures are not saved. Furthermore, the persistence network is backed by a memory based implementation, the actual persistence.ini file is completely ignored. %s and  %s go to a memory backed VFS, and http_request is blocked from making actual http calls (the function may be mocked to simulate a web request, however.)]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3691</id>
	<key><![CDATA[In some cases, a more complex mechanism needs to be used, particularly when the item under test does not return a value, but interacts with a value passed in, most generally a closure. In that case, you can use thenDo to give it an action to do when it is called, rather than having it return a value. The closure sent to thenDo will recieve the arguments that were passed in to the original function.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3692</id>
	<key><![CDATA[Unit testing is an important part of writing maintainable and correct code. In most programming languages, unit testing is bolted on after the fact, but MethodScript elevates the concept of unit testing to a first class part of the language specification itself.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3693</id>
	<key><![CDATA[However, there may be legitimate reasons to allow side effects. This is allowed by using the allowSideEffects parameter of the @{TestSuite} annotation. This is false by default, but if set to true, then for that test suite only, none of the external restrictions are enforced (persistence network, read/write, http_request). Additionally, within the test suite, the state of the environment is not reset before each test, though @{BeforeTest} and @{AfterTest} are still run before and after the test. There is also a guarantee that tests will run in order, from top to bottom, and they will not run in parallel. In general, this has many drawbacks, however, and will considerably slow down your unit tests, so should be used sparingly, if ever. Generally, the better solution is to refactor your actual code and tests such that  the tests can run indepenedently of each other.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3694</id>
	<key><![CDATA[Fakes and stubs are already possible to achieve if your code is written in such a way as to take full advantage of interfaces and dependency injection. For instance:]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3695</id>
	<key><![CDATA[Functional Testing]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3696</id>
	<key><![CDATA[What is Unit Testing?]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3697</id>
	<key><![CDATA[Let us suppose we are writing a Calculator class. The following code could be used to unit test the calculator. Let us first take a look at the abbreviated Calculator class.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3698</id>
	<key><![CDATA[Private methods may be called directly from within the test code, and this is not a compile error.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3699</id>
	<key><![CDATA['''Fake objects''' (or ''fakes'') actually have working implementations, but usually take some shortcut which makes them not suitable for production (an in memory database is a good example).]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
</translations>
