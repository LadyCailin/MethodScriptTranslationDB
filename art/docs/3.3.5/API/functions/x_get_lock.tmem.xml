<translations>
<comment></comment>
<translationBlock>
	<id>art-445</id>
	<key><![CDATA[Yes]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-2878</id>
	<key><![CDATA[Examples]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3788</id>
	<key><![CDATA[Vital Info]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3789</id>
	<key><![CDATA[Find a bug in this page? %sEdit this page yourself, then submit a pull request.%s (Note this page is automatically generated from the documentation in the source code.)]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3791</id>
	<key><![CDATA[Usages]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3792</id>
	<key><![CDATA[Sorry, there are no examples for this function! :(]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3795</id>
	<key><![CDATA[Example 1]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3796</id>
	<key><![CDATA[Given the following code:]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3805</id>
	<key><![CDATA[See Also]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3810</id>
	<key><![CDATA[The output might be:]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3813</id>
	<key><![CDATA[None]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-5152</id>
	<key><![CDATA[About]]></key>
	<comment></comment>
	<translation></translation>
	<auto><![CDATA[Abøüt]]></auto>
</translationBlock>
<translationBlock>
	<id>art-5153</id>
	<key><![CDATA[Home]]></key>
	<comment></comment>
	<translation></translation>
	<auto><![CDATA[Hømə]]></auto>
</translationBlock>
<translationBlock>
	<id>art-5154</id>
	<key><![CDATA[Privacy Policy]]></key>
	<comment></comment>
	<translation></translation>
	<auto><![CDATA[Prîvåcʎ Pølîcʎ]]></auto>
</translationBlock>
<translationBlock>
	<id>art-5155</id>
	<key><![CDATA[Sponsors]]></key>
	<comment></comment>
	<translation></translation>
	<auto><![CDATA[Spønsørs]]></auto>
</translationBlock>
<translationBlock>
	<id>art-5156</id>
	<key><![CDATA[Help]]></key>
	<comment></comment>
	<translation></translation>
	<auto><![CDATA[Həlp]]></auto>
</translationBlock>
<translationBlock>
	<id>art-5157</id>
	<key><![CDATA[Team. All rights reserved.]]></key>
	<comment></comment>
	<translation></translation>
	<auto><![CDATA[Təåm. All rîghts rəsərvəd.]]></auto>
</translationBlock>
<translationBlock>
	<id>art-5158</id>
	<key><![CDATA[Docs]]></key>
	<comment></comment>
	<translation></translation>
	<auto><![CDATA[Døcs]]></auto>
</translationBlock>
<translationBlock>
	<id>art-7377</id>
	<key><![CDATA[mixed lock, Callable action]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-7379</id>
	<key><![CDATA[Runs the specified action on the main thread (or a timer thread in cmdline) once the lock is obtained. Note that this lock is the same object as used in synchronized().]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-7380</id>
	<key><![CDATA[The primary difference being that this function always returns immediately, scheduling the task for later (as soon as possible, but with a small, random backoff), whereas synchronized blocks until the lock is obtained. This is an appropriate call to use when running on the main thread, though it can also be used off the main thread as well, though note that regardless of what thread this is started on, it always runs the Callable on the main thread. The lock is re-entrant, but as the function always runs the Callable at some future point, this only matters when used in conjunction with synchronized().]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-7381</id>
	<key><![CDATA[Note that in general, the queue of actions is unbounded, but will perform operations in a FIFO pattern. This is prone to overflowing though, and should not be used for large amounts of inputs. A good example of use for this function is when there is a synchronized block that runs on an external thread, but some sort of relatively infrequent player input has critical sections that must be locked against the same lock. Other than strings, ValueTypes cannot be used as the lock object, and reference types such as an array or other object is required.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-7385</id>
	<key><![CDATA[Usage across the main and off thread.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-7386</id>
	<key><![CDATA[The queue of actions is unbounded, but will perform operations in a FIFO pattern. Only one action is performed at once. This means that code running on the main thread should usually always use this function, and code running on an off thread should usually use synchronized(), which can help prevent queue overload and main thread starvation.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-7387</id>
	<key><![CDATA[The primary difference between this function and synchronized() is that this function always returns immediately, scheduling the task for later (as soon as possible, but with a small, random backoff if the lock is not currently available), obtaining the lock in the process, whereas synchronized blocks until the lock is obtained. This is an appropriate call to use when running on the main thread for instance. Regardless of what thread this is started on, it always runs the Callable on the main thread (or a timer thread in cmdline mode). The lock is re-entrant, (meaning if the current thread has the lock, trying to obtain the lock again will immediately go through) but as the function always runs the Callable at some future point, and only one action at a time, this only matters when used in conjunction with synchronized() blocks.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-7388</id>
	<key><![CDATA[A good example of use for this function is when there is a synchronized block that runs on an external thread, but code that runs on the main thread has critical sections that must be locked against the same lock.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-7389</id>
	<key><![CDATA[Other than strings, ValueTypes cannot be used as the lock object, and reference types such as an array or other object is required.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-7390</id>
	<key><![CDATA[Runs the specified action once the lock is obtained. Note that this lock is the same underlying lock object as used in synchronized(). The action is run on the main thread (or a timer thread in cmdline).]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
</translations>
