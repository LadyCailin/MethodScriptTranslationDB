<translations>
<comment></comment>
<translationBlock>
	<id>art-1715</id>
	<key><![CDATA[Find a bug in this page? %sEdit this page yourself, then submit a pull request.]]></key>
	<comment></comment>
	<translation></translation>
	<auto><![CDATA[Fînd å büg în thîs pågə? %sEdît thîs pågə ʎøürsəlf, thən sübmît å püll rəqüəst.]]></auto>
</translationBlock>
<translationBlock>
	<id>art-1728</id>
	<key><![CDATA[Usage]]></key>
	<comment></comment>
	<translation></translation>
	<auto><![CDATA[Usågə]]></auto>
</translationBlock>
<translationBlock>
	<id>art-2698</id>
	<key><![CDATA[Example]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3276</id>
	<key><![CDATA[Connections]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3277</id>
	<key><![CDATA[The first call would fail, because we are trying to write to a readonly connection.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3278</id>
	<key><![CDATA[Invalid modifiers will cause a warning to be raised during startup, but will otherwise be ignored.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3279</id>
	<key><![CDATA[Any value in this namespace, and cross namespace boundries]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3280</id>
	<key><![CDATA[Any value in this namespace, but don't cross namespace boundries]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3281</id>
	<key><![CDATA[Your code will not need to change to change where data ends up being stored.  To use this feature, you simply need to change the key -> connection mappings in  the persistence.ini file. In the configuration file,  mappings and connection aliases are stored INI style, as shown below. Local file  paths are relative to the configuration file itself.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3282</id>
	<key><![CDATA[The Persistence Network allows for a flexible, efficient, and intuitive way to store your persistence data.  The general idea is that your code doesn't need to know exactly where the data is stored, it simply needs to know what it's address is. Much like the DNS system, you don't need to remember 173.194.37.65, you just need to remember google.com. Persistence data is stored the same way as normal, as far as your code is concerned, but there is an extra layer of abstraction on top that allows you to customize precisely where data is stored  Like the DNS system, instead of knowing precisely how or where the data is stored, you just remember its  "address" (the key name). There are three factors you need to understand when dealing with the Persistence Network: connections, filters, and controls.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3283</id>
	<key><![CDATA[A filter is a simple regex style matcher; if a key matches this filter, it is stored via  this connection. Filters are specified as such: %sfilter=connection%s where  connection is either a full connection URI, or an alias, and filter is a matcher as  specified below. Filters are matched from best fit to worst fit, top to bottom. The  following wildcards are supported:]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3284</id>
	<key><![CDATA[Take what information you will from the data, and feel free to run it on your system to get actual values relevant to your system, not just relative to each other on the test system.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3285</id>
	<key><![CDATA[Filters]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3286</id>
	<key><![CDATA[So, now, let's go over what would happen when we run our code.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3287</id>
	<key><![CDATA[In the above example, the %stransient%s and %sread-only%s flags have been  added to the connection. The specific meaning of each flag is as follows, and they aren't always  applicable to all connection types.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3288</id>
	<key><![CDATA[In addition, several modifier types can be specified, which modify the connection type.  They are specified as extra protocols at the start of the URI.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3289</id>
	<key><![CDATA[Often times you will want to re-use a connection, but you don't want to have to re-specify the  full connection details for each filter. In this case, you can use connection aliases. A  connection alias looks just like a filter, but the filter name starts with a dollar sign.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3290</id>
	<key><![CDATA[We have data stored in a file, persistence.ser, and we want to change the mapping of  storage.player.** over to a database. If we simply changed it in the mapping file, all  the existing data would be hidden. Instead, you must export/import the  individual data beforehand, then change the mappings. Instead, we  can use the transfer tool.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3291</id>
	<key><![CDATA[Controls]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3292</id>
	<key><![CDATA[The third call will store the data in persistence.ser, in the Serialized Persistence format. Notice that our code doesn't care at all where data is actually being stored, or in what format, it is a routing layer on top of the global key=>value storage system.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3293</id>
	<key><![CDATA[This table of data was generated based on the information obtained from the following script:]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3294</id>
	<key><![CDATA[using the following persistence.ini:]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3295</id>
	<key><![CDATA[A note on file based URIs: The file path is specified after two forward slashes, so an absolute  path on unix looks like this: yml:///path/to/file, and an absolute path on windows looks like  this: yml://C:/path/to/file (alternatively yml://C:\path\to\file will also work). On all  platforms, a relative path would look like this: yml://path/to/file. Additionally, file based connections are '''usually''' going to be much faster, but less reliable than SQL based connections, so it is HIGHLY recommended that you use SQL connections, if nothing else, using the zero config SQLite (which is the default). The only case for a file based connection type is when using frequently read/written data, in which case a subset of your keys may be written out to a file based protocol. The %sser%s protocol is the fastest and most compact, but as it stores the data in a lump binary form, it is not (easily) editable by hand, and is prone to total data corruption in the event of any section of the file being corrupted. For a full rundown of the speed comparisons, see the chart below.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3296</id>
	<key><![CDATA[Connection Aliases]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3297</id>
	<key><![CDATA[An important observation that could be made based on this data is that SQLite is  considerably slower than many of the other protocols. This is because SQLite is less prone to data corruption, and is multiprocess safe. SQLite manages its own locking and journaling systems, so it is unlikely to corrupt if a bad write occurs, or if multiple processes are accessing it at once. Due to this, it is the default storage mechanism, despite its slower runtime. The tradeoff of data protection vs. script speed vs. inter-operability is not something that can be generically decided in all cases though, so feel free to change defaults as you see fit. Each protocol has pros and cons, so you must decide which one to use.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3298</id>
	<key><![CDATA[There are several different connection types supported, and each has a slightly different requirement:]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3299</id>
	<key><![CDATA[It is sometimes necessary to transfer data from one data source to another, in which  case you can use the data manager tools to do so. This should be done while the server  is off, to ensure corruption does not occur, though it is possible to do this with the  server running if you're careful. To transfer data, simply specify the keys to match,  and the destination connection. The data will be transferred appropriately. If a  conflict would occur, you will interactively be prompted with an action. After transferring,  these keys, you should update your persistence.ini file to reflect the new mappings.  This is the appropriate way to make modifications  to your data mappings, while ensuring that no data is lost in the process. Consider the  following scenario:]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3300</id>
	<key><![CDATA[For more information on these tools and more, [[%s|see this article]].]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3301</id>
	<key><![CDATA[Filters are what map namespaces to connections. The configuration file (persistence.ini)  is used to specify the actual filters. (An example is shown below). It is important to note that  the namespace conventions followed by the filter system map to the REAL namespace conventions, not  the namespaces you use in code. For instance, if you were to make a call to  %sstore_value('name.of.key', 'value')%s, the value will actually be stored in  %sstorage.name.of.key%s. For a more detailed description of the namespaces, see  [[%s|this wiki page]].]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3302</id>
	<key><![CDATA[Then, elsewhere, instead of rewriting the entire connection string, you may simply use %s$connection]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3303</id>
	<key><![CDATA[The second call would store the data in the SQLite database, stored in the file persistence.db. The key will be the full key 'storage.players.player.info' though, it does not presume that the file is inherently aware of the key prefix, even if it is unique to this file.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3304</id>
	<key><![CDATA[Sometimes, however, you have data in a source that isn't currently mapped in. In this  case, you want to use the merge tool. Accordingly, if you want  to copy data, and not move it, you also want to use the merge tool. You can also use the  data manager to show hidden data, that is, data that is stored in the data store  somewhere, but isn't accessible due to bad mappings.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3305</id>
	<key><![CDATA[There are special implementation considerations you must take into account if you are writing  an external system that integrates with the persistence network, (including if you edit the  files by hand), so you should read up on the [[%s|Persistence Network Integration]]  guide before you attempt to edit the output files, or otherwise care about the internal storage specifications.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3306</id>
	<key><![CDATA[Data Source Comparisons]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3307</id>
	<key><![CDATA[A connection is a read/write or read-only data source, to which persistence data is mapped. There are several supported formats, and there is the potential to add more in the future. In your configuration file, a connection can be aliased, to make re-specifying a connection  easier, but the actual connection specification is a URI that maps to a specific data source.  For instance, the default SQLite format is simply a pointer to a file:]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3308</id>
	<key><![CDATA[Then it would be stored in $connection1, since that is a more specific match. It is defined  as a more specific match, because, minus wildcards, more namespaces match. This mechanism of  filter competition allows for very specific control over what data goes where, while also not  having to worry about providing specific filters for all possible namespaces. If not otherwise  specified, or if the connection is invalid, The filter ** is ALWAYS defined to be a connection  to the default serialized persistence file, so all otherwise unmatched keys will go there.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-3309</id>
	<key><![CDATA[If we are attempting to store a value in "storage.key.name", and we have the following  two filters defined:]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>art-5152</id>
	<key><![CDATA[About]]></key>
	<comment></comment>
	<translation></translation>
	<auto><![CDATA[Abøüt]]></auto>
</translationBlock>
<translationBlock>
	<id>art-5153</id>
	<key><![CDATA[Home]]></key>
	<comment></comment>
	<translation></translation>
	<auto><![CDATA[Hømə]]></auto>
</translationBlock>
<translationBlock>
	<id>art-5154</id>
	<key><![CDATA[Privacy Policy]]></key>
	<comment></comment>
	<translation></translation>
	<auto><![CDATA[Prîvåcʎ Pølîcʎ]]></auto>
</translationBlock>
<translationBlock>
	<id>art-5155</id>
	<key><![CDATA[Sponsors]]></key>
	<comment></comment>
	<translation></translation>
	<auto><![CDATA[Spønsørs]]></auto>
</translationBlock>
<translationBlock>
	<id>art-5156</id>
	<key><![CDATA[Help]]></key>
	<comment></comment>
	<translation></translation>
	<auto><![CDATA[Həlp]]></auto>
</translationBlock>
<translationBlock>
	<id>art-5157</id>
	<key><![CDATA[Team. All rights reserved.]]></key>
	<comment></comment>
	<translation></translation>
	<auto><![CDATA[Təåm. All rîghts rəsərvəd.]]></auto>
</translationBlock>
<translationBlock>
	<id>art-5158</id>
	<key><![CDATA[Docs]]></key>
	<comment></comment>
	<translation></translation>
	<auto><![CDATA[Døcs]]></auto>
</translationBlock>
<translationBlock>
	<id>art-7717</id>
	<key><![CDATA[A note on file based URIs: The file path is specified after two forward slashes, so an absolute  path on unix looks like this: yml://path/to/file, and an absolute path on windows looks like this: yml://C:/path/to/file (alternatively yml://C:\path\to\file will also work). On all  platforms, a relative path would look like this: yml://path/to/file. Additionally, file based connections are '''usually''' going to be much faster, but less reliable than SQL based connections, so it is HIGHLY recommended that you use SQL connections, if nothing else, using the zero config SQLite (which is the default). The only case for a file based connection type is when using frequently read/written data, in which case a subset of your keys may be written out to a file based protocol. The %sser%s protocol is the fastest and most compact, but as it stores the data in a lump binary form, it is not (easily) editable by hand, and is prone to total data corruption in the event of any section of the file being corrupted. For a full rundown of the speed comparisons, see the chart below.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
</translations>
