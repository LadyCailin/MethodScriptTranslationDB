<translations>
<comment></comment>
<translationBlock>
	<id>nb-1715</id>
	<key><![CDATA[Find a bug in this page? %sEdit this page yourself, then submit a pull request.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2295</id>
	<key><![CDATA[Scope]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2681</id>
	<key><![CDATA[Running inside an event handler]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2682</id>
	<key><![CDATA[@event['location']: The (x, y, z, world) location of the block they clicked]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2683</id>
	<key><![CDATA[set_timeout%s allows you to wait x seconds, then run some code. %sset_interval%s allows you to run  some code every x seconds. Much the same way %sbind%s works, a unique id is returned that represents this  interval or timeout's closure, and you may %sunbind%s the interval or timeout. If you need to know the the id  of the event, you may also force an id on the event, subject to the same restrictions as %sbind%s's  restrictions on ids. These functions are much like Javascript's setInterval and setTimeout functions if you are familiar  with that language, and in fact are modeled after it.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2684</id>
	<key><![CDATA[Event handlers (the code inside a %sbind%s) are fired off in order from highest to lowest, then monitor. All  CommandHelper events are cancellable; that is to say that if an event is cancelled, a flag is set and  %s will return true, and if the underlying minecraft event is also cancellable, it will also be  cancelled. To cancel an event, call %scancel([state])%s in your code. The rest of your code will continue  running, so if you need to stop after cancelling, you should %sreturn()%s.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2685</id>
	<key><![CDATA[The rest of the data in the event is dependent on the event type, and this information can be looked up in the event  table.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2686</id>
	<key><![CDATA[Highest: Highest level handlers receive the event first. Handlers that need to have absolute say about the event should register at this level.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2687</id>
	<key><![CDATA[Events have the same type of scope as functions, i.e. only variables passed in are assigned. This is what the custom  params are for. If you need to have these values passed in to the event, you may do that with these extra parameters.  The values are copied over ''at bind time'', not at event run time. Though the values in the variables may be changed  during the execution of the script, they are reset to the bind time values each time the function is triggered. Using  %s and %s is a good way to get data in and out of the event handlers, if needed,  though you may consider redesigning if you're doing it this way, because there is likely a simpler way.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2688</id>
	<key><![CDATA[Any values %sed from the code are ignored, but will cause the event handler to stop running, which can  be a convenient way to stop the handler short.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2689</id>
	<key><![CDATA[Lowest: Lowest priority handlers should expect to not be able to edit parameters, or even run, but should instead be a "default" occurrence, should nothing else choose to deal with this event.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2690</id>
	<key><![CDATA[Manually Triggering Events]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2691</id>
	<key><![CDATA[Handler priorities are handled as such: Suppose we have three events registered, at high, low, and lowest. The handler  at high gets the event first. The handler is free to modify event parameters, which will then be passed to the low  priority handler, which is then allowed to further modify the event as required, and then it is passed on further to the  lowest priority handler, which is also free to edit the event parameters. Finally, the monitor level handlers are  allowed to see a read-only version of the event. This chain can be modified in two ways. First, a handler may call  %s on an event, which will cause calls to %smodify_event%s by lower priority handlers to fail.  Events essentially become read only at that point, however handlers may still react otherwise. In addition, parameters  may be sent to %slock()%s, which will only lock the specified event parameters, leaving the rest of the  parameters freely editable by lower priority handlers. The second option a higher priority handler has, is to  %s an event. If an event is consumed, it is not even passed to lower priority handlers (except  monitor). This will prevent lower priority events from even seeing the event in the first place.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2692</id>
	<key><![CDATA[@event['block']: The id of the block they clicked, or 0 if they clicked the air. If they clicked the air, neither facing or location will be present.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2693</id>
	<key><![CDATA[If you are having trouble getting a script to do what you want, especially if you have many scripts running, it may be  helpful to use some of the debugging tools at your disposal. %s will print out all the currently  bound events, including their exact location in your script, so you can easily refer to it. Also, if you need to get  meta information at runtime, you can use the following code snippet:]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2694</id>
	<key><![CDATA["macrotype" - This determines what kind of data there will be in the rest of the event]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2695</id>
	<key><![CDATA[Unregistering an Event]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2696</id>
	<key><![CDATA[In the case where we assign our own id, so that we can persist, or otherwise always know what our event's id is, we can  use the following syntax]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2697</id>
	<key><![CDATA[To register an event, use the %s function. Let's take a look at the function's signature:]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2698</id>
	<key><![CDATA[Example]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2699</id>
	<key><![CDATA[High: Handlers that play an important role, but don't need absolute say over an event should register as a high priority handler.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2700</id>
	<key><![CDATA[In order to initially register an event, you must include a hook inside a "main" function. Upon server startup, any  script in main.ms will be run. This should be used as an opportunity to register your initial hooks. Now, this doesn't  prevent you from registering a hook elsewhere in a script, but for the common case, you'll want to put your hooks in  here. You can also use this opportunity to do other things, perhaps writing out to the console or something, but  typically only event registrations will be in here. This does work as a "server start" event, but it gets re-run  whenever you /reloadaliases also.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2701</id>
	<key><![CDATA[Normal: Normal priority handlers intend on being run as they expect, but there would be not be a big loss if they weren't able to run as intended.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2702</id>
	<key><![CDATA[Registering an Event]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2703</id>
	<key><![CDATA[Monitor: Monitor level handlers receive the event last, and cannot edit the event in any way. This should be used for logging type handlers. In general, if the handler hooks in to game functionality (even if it doesn't intend on modifying the event) it should register at Lowest or Low. The exception to this is if a handler wants to get the event even if it is cancelled or consumed, at which point it is appropriate to use monitor. Monitor level handlers still receive cancelled and consumed events, and can check the status of those flags with the %sis_cancelled()%s and %sis_consumed()%s functions.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2704</id>
	<key><![CDATA[player_interact:]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2705</id>
	<key><![CDATA[@event['facing']: The (lowercase) face of the block they clicked.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2706</id>
	<key><![CDATA[Low: Handlers that don't need to run at all, but would like to be able to edit and see at least some events should register at low priority.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2707</id>
	<key><![CDATA[Return]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2708</id>
	<key><![CDATA[So, what's going on here? @event contains the event data. It is an associative array that contains at least the  following information:]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2709</id>
	<key><![CDATA[Each event returns some piece of data that uniquely identifies this registration. To unregister an event, you need to  know this data (i.e., store it in a variable). This data is not guaranteed to be unique across reloads of the server  however, so persisting it across reloads doesn't make sense. If you need to always know what the event id is, you can  force a particular id on the event. This id must be unique across all events. To ensure the data is unique compared to  automatically generated event ids, you may not register an id with the following syntax: "string:int". This formatting  is enforced by the function. To unregister the handler, use the %s function. Let's look at actual code  to more clearly see usage.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2710</id>
	<key><![CDATA[So, what is the purpose of all this complexity in handler priorities? When handlers fight, things can get messy, and  simply having 5 or 6 priority levels isn't usually enough flexibility to specify the desired behavior. For instance,  if a handler absolutely needs to read the original value of an event parameter and act on the event externally, but only  trigger something else as long as some other parameter is some value upon it actually triggering, this would be  impossible without the callbacks. Or if a handler wants to act on some event, and other events also acting on it would  cause issues, it can consume the event, and not have to worry about undesired behavior. This is why choosing a priority  is important, and the priority you choose should be based on the following guidelines:]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2711</id>
	<key><![CDATA[Order of events]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2712</id>
	<key><![CDATA[Debugging]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2713</id>
	<key><![CDATA[Sometimes it may be desirable to manually trigger an event. Each event has it's own requirements for exactly what is  required to fire it, but all the events use the %s function. The exact requirements can be found in  the documentation with the event in the Event API.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2714</id>
	<key><![CDATA[In addition, an event may unregister itself from within the handler by running %sunbind()%s without any  arguments. This will cause the handler to no longer run, but it will finish running this last time. This is useful for  onetime event handlers, perhaps if the event was registered in a command.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2715</id>
	<key><![CDATA[The context of events are sometimes different than when a command is run. For instance, in a mob spawn event, no player  is involved, so %s will return %s. For player based events however, player() does return the player  that triggered the event.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2716</id>
	<key><![CDATA[@event['player']: The player associated with this event]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2717</id>
	<key><![CDATA["type" - The event type. Normally you've already got this data, because you registered it, however, wildcard events may be possible in the future.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2718</id>
	<key><![CDATA[In the event that two or more handlers register at the same priority, other handlers will receive the event even if it  is consumed (however, they can not cause it to stop being consumed) and they can still modify the event parameters  (though they cannot "unlock" the event for lower priority handlers). The order that handlers fire in within priorities  is determined by bind order.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2719</id>
	<key><![CDATA[So, what happens? If the player left clicks a block, it will tell them the block id they just clicked. Not terribly  useful by itself, but that should give you an idea of how events work in general.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2720</id>
	<key><![CDATA[If you note, this looks very similar to the %s function. In essence, it's basically the same, except  CommandHelper is responsible for calling the function, when the specified event occurs, not you. The options object  allows you to set certain options for this event, including setting a custom event id, and event priority. The prefilter  allows you to tell the event handler to pre-filter which events are intercepted (Prefilters are a more complicated  subject, and have their own [[%s|page]]). Both the options parameter and the prefilter  parameter may be %s. The information in the @event_object depends on the event. Each event sends different parameters.  Finally, the custom params are discussed below in the scope section. So, let's look at the %splayer_interact%s  event, which occurs whenever the player left or right clicks a block or the air, and show a few use cases. First, we  need to know the event's signature though, which can be looked up in the [[%s|Event API]].]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2721</id>
	<key><![CDATA[@event['action']: One of either: left_click_block, right_click_block, left_click_air, or right_click_air]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2722</id>
	<key><![CDATA[Event handling allows users to register MScripts to be triggered in many other places, not just on a command. This  expands the usefulness of CommandHelper to the point where it is roughly equivalent to any other plugin that can be  written for Minecraft.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2723</id>
	<key><![CDATA[main.ms]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-2724</id>
	<key><![CDATA[Because the event handler is registered at monitor level, it will run last, and it will print out meta information about  the active event, including information about what handlers received, locked, consumed, modified, or cancelled events.  Because logging information for %s does use marginally more resources, history is only logged if  debug mode is on (this can be set in preferences.txt).]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-5152</id>
	<key><![CDATA[About]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-5153</id>
	<key><![CDATA[Home]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-5154</id>
	<key><![CDATA[Privacy Policy]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-5155</id>
	<key><![CDATA[Sponsors]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-5156</id>
	<key><![CDATA[Help]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-5157</id>
	<key><![CDATA[Team. All rights reserved.]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
<translationBlock>
	<id>nb-5158</id>
	<key><![CDATA[Docs]]></key>
	<comment></comment>
	<translation></translation>
	<auto></auto>
</translationBlock>
</translations>
